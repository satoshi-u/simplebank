===============================================================================================================================================
1 -> Schema Essentials

        drew the schema here and get simple-bank.pdf/simple-bank.sql : https://dbdiagram.io/d/6443ae366b3194705103b899

===============================================================================================================================================
2 -> Docker Essentials

        start postgres docker container
        # docker run --name simple-bank-db -p 5432:5432 -e POSTGRES_USER=root -e POSTGRES_PASSWORD=secret -d postgres:12-alpine

        run cmd inside container (pw not required because image sets up trust authentication locally)
        # docker exec -it simple-bank-db psql -U root
        # select now();

        get all containers
        # docker ps -a

        get logs of container
        # docker logs simple-bank-db

        stop container
        # docker stop simple-bank-db

        remove container
        # docker rm simple-bank-db

        restart container
        # docker start simple-bank-db

        go inside container
        # docker exec -it simple-bank-db bash
        # docker exec -it simple-bank-db /bin/sh

        create a new db with psql cli from inside or directly
        # createdb --username=root --owner=root simple_bank
        # docker exec -it simple-bank-db createdb --username=root --owner=root simple_bank

        access new db with psql cli from inside or directly
        # psql -U root simple_bank
        # docker exec -it simple-bank-db psql -U root simple_bank

        delete new db with psql cli from inside or directly
        # dropdb simple_bank
        # docker exec -it simple-bank-db dropdb simple_bank

        makefile -> easy to setup in local for new folks in project

===============================================================================================================================================
3 -> DB Migration Essentials

        Install cli golang-migrate
        # brew install golang-migrate

        create migrate dir for project
        # migrate create -ext sql -dir db/migration -seq init_schema

        run migrate up/down (included in makefile)
        # migrate -path db/migration -database "postgresql://root:secret@localhost:5432/simple_bank?sslmode=disable" -verbose up
        # migrate -path db/migration -database "postgresql://root:secret@localhost:5432/simple_bank?sslmode=disable" -verbose down

===============================================================================================================================================
4 -> Generate golang CRUD from SQL

        use for doing low-level custom queries : https://pkg.go.dev/database/sql
        use for doing high-level queries : https://pkg.go.dev/gorm.io/gorm
        faster alt : https://pkg.go.dev/github.com/jmoiron/sqlx
        faster, autogen & compile-time alt: https://pkg.go.dev/github.com/kyleconroy/sqlc

        Install sqlc
        # brew install sqlc

        Init - genrates a yaml with empty settings. For more : https://github.com/kyleconroy/sqlc/tree/v1.4.0
        # sqlc init

        Init go project and tidy project
        # go mod init github.com/web3dev6/simplebank
        # go mod tidy

        Generate code (included in makefile, add .sql in db/query and then run)
        # sqlc generate

===============================================================================================================================================
5 -> Golang unit tests for db CRUD

        note*
            go get github.com/lib/pq
            Add _ "github.com/lib/pq" in imports for the pgdb driver to work properly
            go mod tidy to fix go.mod dependency

        Matching test results in go tests
        go get github.com/stretchr/testify

        note*
            Added unit tests for account, entry and transfer db CRUD generated code, which use testQueries conn created in main_test 
        
        go test ./...

===============================================================================================================================================
6 -> SQL DB Txn

        note*
            updated Store to have both Queries and sql.db both
            wrote a generic execTx to carry out SQL DB Txns
            used execTx to carry out multiple create/update queries in one single Tx
            wrote unit test(s) for store 

===============================================================================================================================================
7 -> DB Txn Lock & dealing with Deadlocks

        note*
            deadlocks happen because of concurrent txns in db
            tx2 : {create transfer}[ok]
            tx2 : {create entry}[ok]
            tx1 : {create transfer}[holding-exclusive-lock]... LOCK HERE
            tx2 : {create entry}[ok]
            tx2 : {get account}[waiting-shared-lock]... WAITING LOCK
            tx1 : {create entry}[ok]
            tx1 : {create entry}[ok]
            tx1 : {get account}[waiting-shared-lock]... DEADLOCK

        note*
            one way to avoid deadlocks is by removing the foreign key constraints on tables[ACCOUNT<->TRANSFER]

            lock is required by "tx1 : {create transfer}" as postgres worries that other txs might update the transfer table's referred from-account-id/to-account-id in accounts table,
            thereby it must guard the foreign key constraint whilst updating the transfer record
            one potential solution is in query "select account for update",
            we must specify that pk won't be touched in "update account" query which is true also
            # SELECT * FROM accounts WHERE id = $1 LIMIT 1 FOR NO KEY UPDATE;
            Regenerate autogen code sqlc with updated account.sql
            # make sqlc

            optimize running 2 queries @account{get-update} by having a single query @account{update}

===============================================================================================================================================
8 -> Avoid Deadlocks - keep order same

        note*
            Deadlock can still happen because of concurrent txns updating pair of same records in different order
            To avoid, make txns update the records in same order always

            Application must acquire locks in a consistent order

===============================================================================================================================================
9 -> Isolation Levels & Read Phenomenon

        ACID -
                Atomicity   : Either all operations complete successfully or txn fails and db left unchanged
                Consistency : Db state must be valid after the tx, all constraints must be satisfied
                Isolation   : Concurrent txns must not affect each other
                Durability  : Data written by a successful tx must be recorded in persistent storage

        read Phenomenon: -
                Dirty Read            : A txn reads data written by other uncommitted tx
                Non Repeatable Read   : A txn reads the same row twice and sees different value as it got modified by other committed tx
                Phantom Read          : A txn reads a set of rows(based on some condition) twice and sees different values as it got modified by other committed tx
                Serialization Anomaly : The result of a group of concurrent committed txns is impossible to achieve if we run same txns sequentially(no overlaps) in any order
                                        case a. run concurrently 2 times (sum up balance of accounts in table and create new account with that sum as balance)
                                             b. run sequentially 2 times (sum up balance of accounts in table and create new account with that sum as balance)
                                             -> both give different results

        4 std isolation levels -
            Read Uncommitted  <->   doesn't even prevent Dirty Read
            Read Committed    <->   prevents Dirty Read, but Non Repeatable Read & Phantom Read can occur
            Repeatable Read   <->   prevents Dirty Read, Non Repeatable Read & Phantom Read but Serialization Anomaly can occur
            Serializable Read <->   prevents even Serialization Anomaly
        NOTE: rules only applicable for read queries, write is always in sync or throws error
        NOTE: you might wanna have txn retries in place when writes/updates are failed in Repeatable Read/Serializable Read
        NOTE: in postgres, read uncommitted behaves as read committed
        NOTE: in mysql, update to same entry is allowed to happen in concurrent txns with repeatable read mode
        NOTE: in postgres, update to same entry throws error in concurrent txns with repeatable read mode
        NOTE: in mysql's serializable read, serializable anamoly is prevented by throwing deadlock in 2nd txn in concurrent txns affecting same rows
        NOTE: in postgres's serializable read, serializable anamoly is prevented by throwing error in 2nd txn(tells to retry) in concurrent txns affecting same rows

        For an open mysql session,
            get mysql's current isolation level (default is repeatable read)
            # select @transaction_isolation

            get mysql's global isolation level
            # select @global.transaction_isolation

            mysql change isolation level
            # set session transaction isolation level read uncommitted;
            # set session transaction isolation level read committed;
            # set session transaction isolation level repeatable read;
            # set session transaction isolation level serializable read;
        
         For an open postgres session,
            get postgres's current isolation level (default is read committed)
            # show transaction isolation level

            postgres change isolation level - at txn level
            # begin
            # set transaction isolation level read uncommitted;
            # set transaction isolation level read committed;
            # set transaction isolation level repeatable read;
            # set transaction isolation level serializable read;








